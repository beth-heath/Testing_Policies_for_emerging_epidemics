occupancy_data$type <- 1:nrow(occupancy_data)
communal <- read_xls('')
`%ni%` <- Negate(`%in%`)
set.seed(123)
#loading in the data
occupancy_data <- read_xls('/Users/bethanyheath/Downloads/Dat.xls',sheet=2)
#Naming the columns after the variables
colnames(occupancy_data) <- occupancy_data[9,]
#Removing the bit at the top of the document that was not needed
occupancy_data <- occupancy_data[-c(1:9),]
#renaming column name
occupancy_data$`Household Size`[occupancy_data$`Household Size`=="11 or more people in household"] <- '11 people or more'
#sums up the number of people in the household
occupancy_data$number <- as.numeric(sapply(occupancy_data$`Household Size`,function(x)strsplit(x,' p')[[1]][1]))
#getting rid of the blank NAs role from inbetween the i and i+1 sections
occupancy_data <- subset(occupancy_data,!is.na(number))
#The 11 plus section does not have the totals written in certain places so this is including them in
occupancy_data[286,5] <- as.character(6432)
occupancy_data[286,7] <- as.character(occupancy_data[286,8])
#Applying across the columns it takes the subset of whose number equals a certain value such as 1 takes their total and sums it. Essentially it is working out the number of households that have a certain number of inidividuals.
households <- sapply(1:10,function(y)sum(as.numeric(subset(occupancy_data,number==y)$Total)))
#This is doing a similar job to the previous question but is multiplying the household by the number of people.
people <- sapply(1:10,function(y)sum(as.numeric(subset(occupancy_data,number==y)$Total))*y)
#Just assigning a number to each of the cases.
occupancy_data$type <- 1:nrow(occupancy_data)
communal <- read_xls('/Users/bethanyheath/Downloads/communal_living.xls',sheet=1)
economic <- read_xls('/Users/bethanyheath/Downloads/communal_living_economic.xls',sheet=1)
#Previous section was about loading in the data that will be used to build the model.
#Next stage is about creating the network that will be used to build the model.
#set the number of households to 500
number_of_households <- 500
#set up the type for these 500 household by choosing based on the probability taken from the data already loaded in
household_types <- sample(occupancy_data$type,number_of_households,replace=T,prob=occupancy_data$Total)
#renaming variables
colnames(occupancy_data)[1:4] <- c('description','children','adults','elderly')
#setting the size of the household based on what type of household was chosen
household_sizes <- occupancy_data$number[household_types]
label_start <- 0
#hh is a list with the number of households there are then says to make a  full graph then set vertex attribution to the initial start plus household sizes.
hh <- list()
for(i in 1:number_of_households) {
hh[[i]] <- make_full_graph(household_sizes[i]) %>%
set_vertex_attr("name", value = label_start+1:household_sizes[i])
label_start <- label_start + household_sizes[i]
}
# extract household data frames
attrs <- do.call(rbind,lapply(hh,function(x)igraph::as_data_frame(x,'vertices')))
# combine all
el <- do.call(rbind,lapply(hh,function(x)igraph::as_data_frame(x)))
# convert to network
new_g <- graph_from_data_frame(el, directed = FALSE, vertices = attrs)
# save layout for plotting
pts <- 80
save_layout <- layout_nicely(induced.subgraph(new_g,1:pts))
# add household labels
hh_labels <- rep(1:number_of_households,household_sizes)
#setting the vertex attributes to what has been worked out
new_g <- set_vertex_attr(new_g,'hh',value=hh_labels)
#ego finds the vertices not further from the neighbourhood of the vertices
household_list <<- lapply(V(new_g),function(x) {cs <- as.vector(unlist(ego(new_g,order=1,nodes=x))); cs[cs!=x]})
#combining the houses together including the children adults and eldery together.
house_makeup <- lapply(2:nrow(occupancy_data)-1,function(x)as.numeric(c(occupancy_data$children[occupancy_data$type==x],
occupancy_data$adults[occupancy_data$type==x],
occupancy_data$elderly[occupancy_data$type==x])))
#for the residents they have find the number of the residents for each of the number of households. Setting up measures given which household are together.                                                                         occupancy_data$elderly[occupancy_data$type==x])))
demographic_index <- rep(0,length(V(new_g)))
for(i in 1:number_of_households){
residents <- which(hh_labels==i)
occupants <- house_makeup[[household_types[i]]]
labels <- rep(1:3,times=occupants)
demographic_index[residents] <- labels
}
demographic_index <<- demographic_index
#code to assign ages to the children, adults and eldery sections
min_age <- c(0,10,20,30,40,50,60,70,80)
max_age <- c(9,19,29,39,49,59,69,79,150)
cfr <- c(0.002,0.006,0.03,0.08,0.15,0.6,2.2,5.1,9.3)/100
grouped_cfr <<- c(mean(cfr[1:2]),mean(cfr[3:7]),mean(cfr[8:9]))
tune <<- grouped_cfr/max(grouped_cfr)
#states the number of indivduals in the samples that are children, adults and elderly.
paste0(sum(demographic_index==1),' children')
paste0(sum(demographic_index==2),' adults')
paste0(sum(demographic_index==3),' elderly')
# Next section is about creating work connections between individuals. In the current code this does not take into account: children and eldery not working, communal/institutional living, social
#Next section is counting how many individuals are working
#Create a new measure that will be used to count this up
worker_index <- rep(0,length(demographic_index))
#Next each adult is considered to be in the working population. This is easily adjustable by adding a probability into this.
worker_index[demographic_index==2] <- 1
#Elders are considered in the population but only those that would be below a certain age therefore to take this into account, we get:
worker_index[demographic_index==3&runif(length(worker_index))<0.2] <- 1
#Calculating the number working from summing this measure calculated
n_adults <- sum(worker_index)
# number of workplaces calculated using a rpois distribution using information from https://www.hse.gov.uk/contact/faqs/toilets.htm
number_workplaces <- rpois(1,n_adults/15)
#setting up for the workplace index
workplace_index <- rep(0,length(V(new_g)))
#takes a sample from the number of workplaces for the number of adults who work there are in the sample therefore each working member gets assigned a number for their workplace
workplace_index[worker_index==1] <- sample(1:number_workplaces,n_adults,replace=T)
#add in work connections into the model which works by looking at people who work in the same workplace adds connections between them.
for(i in 1:number_workplaces) {
workers <- which(workplace_index==i)
if(length(workers)>1)
for(j in 2:length(workers))
for(k in 1:(j-1)){
new_g <- add_edges(new_g,edges=c(workers[j],workers[k]))
}
}
## Children in classrooms
young_people <- V(new_g)[demographic_index==1]
Number_classes <- rpois(1, length(young_people)/25)
School_index <- rep(0, length(V(new_g)))
School_index[demographic_index==1] <- sample(1:Number_classes, length(young_people), replace=T)
for(i in 1:Number_classes) {
pupils <- which(School_index==i)
if(length(pupils)>1)
for(j in 2:length(pupils))
for(k in 1:(j-1)){
new_g <- add_edges(new_g,edges=c(pupils[j],pupils[k]))
}
}
par(mar=c(1,1,1,1))
plot(induced.subgraph(new_g,1:pts),layout=save_layout,
vertex.label=NA,vertex.size=10,vertex.color=c('white',"#660066","#CC99FF")[demographic_index[1:pts]])
legend('topleft',legend=c('<19','19-65','>65'),pt.cex=2,col='black',pch=21, pt.bg=c('white',"#660066","#CC99FF"),bty='n')
#Plotting graph of the connections
#plot.igraph(new_g,vertex.label=NA,vertex.size=1,layout=save_layout)
#Looking at the size of the clusters
cluster_sizes <- sapply(V(new_g),function(x)ego_size(new_g,order=2,nodes=x))
#hist(cluster_sizes,main='',xlab='Cluster size')
#looking at the degree distribution
degreedistribution <- degree.distribution(new_g)*length(E(new_g))
#works out the average contacts per person
average_contacts <- sum(degreedistribution*c(1:length(degreedistribution)-1)/length(E(new_g)))
length(E(new_g))/length(V(new_g))*2
#lists the people that each individual has contact with in the model
contact_list <<- lapply(V(new_g),function(x) {cs <- as.vector(unlist(ego(new_g,order=1,nodes=x))); cs[cs!=x]})
#creates list of those who are contacts of the person's contacts
contact_of_contact_list <<- lapply(V(new_g),function(x) {
cs <- as.vector(unlist(ego(new_g,order=1,nodes=x)));
cofcs <- as.vector(unlist(ego(new_g,order=2,nodes=x)));
ccs <- funique(c(cs,cofcs))
ccs[ccs!=x]
})
## generate random edges network for random transmission
#random graph as according to the Erdos-Renyi model every edge created with the same constant probability in this caser the probabilityu is 10/length of vertices
random_g <- sample_gnp(length(V(new_g)), 10/length(V(new_g)))
#creates a list of all the vertices that they are attached to as a result of these random interactions
random_list <<- lapply(V(random_g),function(x) {cs <- as.vector(unlist(ego(random_g,order=1,nodes=x))); cs[cs!=x]})
## adding in random connections to simulate social connections
social_g <<- new_g
social_g <- add_edges(social_g, edges=c(1,2))
for (i in 1:1650){
listing_one <-sample(V(social_g),11000, replace = TRUE)
listing_two <- sample(V(social_g), 11000, replace = TRUE)
one_pair <-unlist(unname(as.list(listing_one[i])))
two_pair<-unlist(unname(as.list(listing_two[i])))
social_g <-add_edges(social_g, edges = c(one_pair, two_pair))
}
social_list <<- lapply(V(social_g),function(x) {cs <- as.vector(unlist(ego(social_g,order=1,nodes=x))); cs[cs!=x]})
plot(induced.subgraph(social_g,1:pts),layout=save_layout,
vertex.label=NA,vertex.size=10,vertex.color=c('white',"#660066","#CC99FF")[demographic_index[1:pts]])
legend('topleft',legend=c('<19','19-65','>65'),pt.cex=2,col='black',pch=21, pt.bg=c('white',"#660066","#CC99FF"),bty='n')
`%ni%` <- Negate(`%in%`)
## functions #######################################################
source('Random_pooled_10_tests.R')
setwd('/Users/bethanyheath/OneDrive/bethany/PhD/Code for submission')
library(igraph)
library(truncnorm)
library(infotheo)
library(xtable)
library(RColorBrewer)
library(plotrix)
library(profvis)
library(funique)
library(doParallel)
library(foreach)
library(survival)
library(coxme)
library(pracma)
library(dplyr)
library(readxl)
#library(rethinking)
library(rBeta2009)
## build network ###############################################################
#source('Network_set.R')
`%ni%` <- Negate(`%in%`)
## functions #######################################################
source('Random_pooled_10_tests.R')
ref_recruit_day <<- 30
eval_day <<- 25
target_weight <<- 24
ve_est_threshold <<- 0.005
break_threshold <<- 5
#Spread code in the less social interactions case
covid_spread_wrapper <- function(i_nodes_info,s_nodes,v_nodes,e_nodes_info,isolation_individuals, direct_VE){
# to contacts
# e infects house and work and anyone - only enodes infected one day ago or more, and only enodes with one day left incubating
##!! a subset of i_nodes are nonsymptomatic and therefore continue to infect contacts. these should be a fixed list, not sampled randomly every time.
current_infectious <- c(i_nodes_info[,1],e_nodes_info[e_nodes_info[,2]>=e_nodes_info[,3],1])
available_infectors <- current_infectious[current_infectious %ni% isolation_individuals]
non_isolating <- current_infectious %ni% isolation_individuals
available_infectors <- current_infectious[non_isolating]
if(length(available_infectors)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,available_infectors,direct_VE,incperiod_shape,incperiod_rate,susc_list=contact_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,available_infectors,direct_VE,incperiod_shape,incperiod_rate,susc_list=random_list,beta_scalar=random_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
#i infects house - changing code so that only those that have tested positive - currently have that testing occurs every day
infected_and_isolated <- current_infectious[current_infectious %in% isolation_individuals]
if(length(isolation_individuals)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info, infected_and_isolated,direct_VE,incperiod_shape,incperiod_rate,susc_list=household_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
return(e_nodes_info)
}
#Spread in the case with more social interactions
covid_spread_wrapper_2 <- function(i_nodes_info,s_nodes,v_nodes,e_nodes_info,isolation_individuals, direct_VE){
# to contacts
# e infects house and work and anyone - only enodes infected one day ago or more, and only enodes with one day left incubating
##!! a subset of i_nodes are nonsymptomatic and therefore continue to infect contacts. these should be a fixed list, not sampled randomly every time.
current_infectious <- c(i_nodes_info[,1],e_nodes_info[e_nodes_info[,2]>=e_nodes_info[,3],1])
if(length(current_infectious)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=contact_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=random_list,beta_scalar=random_scalar)
s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=social_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
#i infects house - changing code so that only those that have tested positive - currently have that testing occurs every day
if(length(isolation_individuals)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,isolation_individuals,direct_VE,incperiod_shape,incperiod_rate,susc_list=household_list,beta_scalar=0.2)
}
return(e_nodes_info)
}
## set up #######################################################
# Per-time-step hazard of infection for a susceptible nodes from an infectious
# neighbour
beta_base <<- 0.01
# Gamma-distribution parameters of incubation and infectious period and wait times
# hist(rgamma(1000,shape=1.43,rate=0.549)+2)
infperiod_shape <<- 1.43
infperiod_rate <<- 0.549
infperiod_const <<- 2
## assume there is no difference between infectious with and without symptoms - all I
#mn <- 6.5 # =shape/rate # 5.2
#sd <- 2.6 # =sqrt(shape/rate^2) # 2.8
# hist(rgamma(1000,shape=13.3,rate=4.16)+2)
incperiod_rate <<- 4.16 # mn/sd^2 #
incperiod_shape <<- 13.3 # incperiod_rate*mn #
incperiod_const <<- 2
#hosp_shape_index <<- 2
#hosp_rate_index <<- 0.5
#hosp_shape <<- 2
#hosp_rate <<- 0.5
recruit_shape <<- 5.4
recruit_rate <<- 0.47
#hosp_mean_index <<- 3.85
#hosp_sd_index <<- 2.76
#hosp_mean <<- 3.85
#hosp_sd <<- 2.76
recruit_mean <<- 10.32
recruit_sd <<- 4.79
enrollment_rate <<- 0
nonrandom_scalar <<- 1
random_scalar <<- 1/10
length(E(new_g))
length(E(random_g))
direct_VE <- 0.0
g <<- new_g
g_name <<- as.numeric(as.vector(V(g)$name))
vertices <- V(g)
cluster_size <- hosp_times <- recruit_times <- c()
results_list <- list()
###########################################################################
set_variables_from_gamma_distributions <- function(){
vacc_shape <<- 3
vacc_rate <<- 1
infperiod_scale <- 1/infperiod_rate
incperiod_scale <- 1/incperiod_rate
vacc_scale <- 1/vacc_rate
mu <- incperiod_shape*incperiod_scale + vacc_shape*vacc_scale
sig2 <- incperiod_shape*incperiod_scale^2 + vacc_shape*vacc_scale^2
alpha <- mu^2/sig2
beta <- sig2/mu
inc_plus_vacc_shape <<- alpha
inc_plus_vacc_rate <<- 1/beta
zero <<- 50
pgamma_vector <<- pgamma(1:100-incperiod_const,shape=inc_plus_vacc_shape,rate=inc_plus_vacc_rate)
dgamma_vector <<- dgamma(1:100-incperiod_const,shape=inc_plus_vacc_shape,rate=inc_plus_vacc_rate)
pgamma_inc_vector <<- c(rep(0,zero),pgamma(1:100-incperiod_const,shape=incperiod_shape,rate=incperiod_rate))
pgamma_vacc_vector <<- c(rep(0,zero),pgamma(1:100,shape=vacc_shape,rate=vacc_rate))
dgamma_inc_vector <<- c(rep(0,zero),dgamma(1:100-incperiod_const,shape=incperiod_shape,rate=incperiod_rate))
recruitment_time <<- 30
}
set_variables_from_gamma_distributions()
#### Additional code ####
nIter <- 200
e_order <- list()
infected_1<-infected_1<-length_1<-no_peaks_1<- peak_1<-isolated_1<-unneccesary_infections1<-threshold_11 <-threshold_21 <- matrix(nrow = 1, ncol=1)
sdinfected_1<-sdinfected_1<-sdlength_1<-sdno_peaks_1<- sdpeak_1<-sdisolated_1<-sdunneccesary_infections1<-sdthreshold_11 <-sdthreshold_21 <-matrix(nrow =1, ncol=1)
#data_collected = matrix (nrow = length(nIter), ncol = 2)
infected_2<- isolated_2<- peak_2<-length_2<-no_peaks_2 <-unneccesary_infections <- threshold_2<-threshold_1<-c()
#profvis(
delay_prob_range <-c(1)
other_symps_range <-c(5)
for (i in delay_prob_range){
for (j in other_symps_range){
for (iter in 1:nIter){
observed <<- 0.8
# select random person to start
first_infected <- sample(g_name, 20)
inf_period <- rgamma(length(first_infected),shape=infperiod_shape,rate=infperiod_rate)
netwk <- simulate_contact_network(first_infected,start_day=iter,from_source=0,cluster_flag=0,individual_recruitment_times=T,spread_wrapper=covid_spread_wrapper,
prob_false_neg = 0.279, tests=10,
non_compliance_prob =0, pools_every_time=5, pool_size=12
)
results_list[[iter]] <- netwk[[1]]
cluster_size[iter] <- netwk[[2]]
peak_2[iter] <- netwk[[10]]
infected_2[iter] <- netwk[[11]]
isolated_2[iter] <- netwk[[12]]
length_2[iter] <- netwk[[13]]
no_peaks_2[iter] <- netwk[[14]]
unneccesary_infections[iter]<-netwk[[17]]
threshold_1[iter] <-netwk[[15]]
threshold_2[iter] <-netwk[[16]]
#recruit_times[iter] <- netwk[[3]]
#    e_order[[iter]] <- netwk[[8]][!duplicated(netwk[[8]])]
#data_collected[iter, 1] = netwk[[11]]
#data_collected[iter, 2] = netwk[[12]]
}
infected_1[which(delay_prob_range==i),which(other_symps_range==j)]<- mean(infected_2)
sdinfected_1[which(delay_prob_range==i),which(other_symps_range==j)] <-sd(infected_2)
length_1[which(delay_prob_range==i),which(other_symps_range==j)]<-mean(length_2)
sdlength_1[which(delay_prob_range==i),which(other_symps_range==j)]<- sd(length_2)
no_peaks_1[which(delay_prob_range==i),which(other_symps_range==j)]<- mean(no_peaks_2)
sdno_peaks_1[which(delay_prob_range==i),which(other_symps_range==j)]<-sd(no_peaks_2)
peak_1[which(delay_prob_range==i),which(other_symps_range==j)] <- mean(peak_2)
sdpeak_1[which(delay_prob_range==i),which(other_symps_range==j)]<- sd(peak_2)
isolated_1[which(delay_prob_range==i),which(other_symps_range==j)]<- mean(isolated_2)
sdisolated_1[which(delay_prob_range==i),which(other_symps_range==j)] <- sd(isolated_2)
unneccesary_infections1[which(delay_prob_range==i),which(other_symps_range==j)] <- mean(unneccesary_infections)
sdunneccesary_infections1[which(delay_prob_range==i),which(other_symps_range==j)]<- sd(unneccesary_infections)
threshold_11[which(delay_prob_range==i),which(other_symps_range==j)] <- mean(threshold_1)
sdthreshold_11[which(delay_prob_range==i),which(other_symps_range==j)] <- sd(threshold_1)
threshold_21[which(delay_prob_range==i),which(other_symps_range==j)] <- mean(threshold_2)
sdthreshold_21[which(delay_prob_range==i),which(other_symps_range==j)]<- sd(threshold_2)
print(infected_1)
}
}
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Pan_Code_GitHub/Set_up_code2.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source('symptomatic_individual_testing_function.R')
ref_recruit_day <<- 30
eval_day <<- 25
target_weight <<- 24
ve_est_threshold <<- 0.005
break_threshold <<- 5
#Spread code in the less social interactions case
covid_spread_wrapper <- function(i_nodes_info,s_nodes,v_nodes,e_nodes_info,isolation_individuals, direct_VE){
# to contacts
# e infects house and work and anyone - only enodes infected one day ago or more, and only enodes with one day left incubating
##!! a subset of i_nodes are nonsymptomatic and therefore continue to infect contacts. these should be a fixed list, not sampled randomly every time.
current_infectious <- c(i_nodes_info[,1],e_nodes_info[e_nodes_info[,2]>=e_nodes_info[,3],1])
available_infectors <- current_infectious[current_infectious %ni% isolation_individuals]
non_isolating <- current_infectious %ni% isolation_individuals
available_infectors <- current_infectious[non_isolating]
if(length(available_infectors)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,available_infectors,direct_VE,incperiod_shape,incperiod_rate,susc_list=contact_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,available_infectors,direct_VE,incperiod_shape,incperiod_rate,susc_list=random_list,beta_scalar=random_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
#i infects house - changing code so that only those that have tested positive - currently have that testing occurs every day
infected_and_isolated <- current_infectious[current_infectious %in% isolation_individuals]
if(length(isolation_individuals)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info, infected_and_isolated,direct_VE,incperiod_shape,incperiod_rate,susc_list=household_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
return(e_nodes_info)
}
#Spread in the case with more social interactions
covid_spread_wrapper_2 <- function(i_nodes_info,s_nodes,v_nodes,e_nodes_info,isolation_individuals, direct_VE){
# to contacts
# e infects house and work and anyone - only enodes infected one day ago or more, and only enodes with one day left incubating
##!! a subset of i_nodes are nonsymptomatic and therefore continue to infect contacts. these should be a fixed list, not sampled randomly every time.
current_infectious <- c(i_nodes_info[,1],e_nodes_info[e_nodes_info[,2]>=e_nodes_info[,3],1])
if(length(current_infectious)>0){
#   e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=contact_list,beta_scalar=nonrandom_scalar)
#    s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=random_list,beta_scalar=random_scalar)
s_nodes[e_nodes_info[,1]] <- 0
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,current_infectious,direct_VE,incperiod_shape,incperiod_rate,susc_list=social_list,beta_scalar=nonrandom_scalar)
s_nodes[e_nodes_info[,1]] <- 0
}
#i infects house - changing code so that only those that have tested positive - currently have that testing occurs every day
infected_and_isolated <- current_infectious[current_infectious %in% isolation_individuals]
if(length(infected_and_isolated)>0){
e_nodes_info <- spread(s_nodes,v_nodes,e_nodes_info,isolation_individuals,direct_VE,incperiod_shape,incperiod_rate,susc_list=household_list,beta_scalar=0.2)
}
return(e_nodes_info)
}
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
warnings()
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
warnings()
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/bethany/PhD/Code for submission/Set_up_codeformodelrun.R", echo=TRUE)
500,000/50,000,000
500000/50000000
0.01*1100
